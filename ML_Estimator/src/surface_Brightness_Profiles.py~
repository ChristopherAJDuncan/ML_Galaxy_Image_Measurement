'''
Module containing the general routines for the production of a non-Pixelised (etc.) surface brightness profile and its derivatives. This particualr version uses sympy to producederivatives of an anlytic function.

Author: cajd
Touch Date: 16 June 2015
'''

import numpy as np

def gaussian_SBProfile_Sympy(xy, cen, isigma, ie1, ie2, iItot, K = 0., g1 = 0., g2 = 0., der = [], printOnly = False, suppressLensing = True):
    import sympy as sp
    '''

    ---der: Sets the parameters to be differentiated with respect to. The size of each sub-list sets the order of differentiation. e.g. to return SB profile, use der = [] (or leave at default. To get d2I/dr2: der = ['size', 'size'], an To get d2I/drde1: der = ['size', 'e1'] etc.

    '''
    ## Edit this to pass in model parameters
    from math import pi

    ## Set up sympy definition of the profile

    #Symbols
    size = sp.Symbol('size')
    e1 = sp.Symbol('e1')
    e2 = sp.Symbol('e2')
    flux = sp.Symbol('flux')
    dx = sp.Symbol('dx')
    dy = sp.Symbol('dy')
    K = sp.Symbol('K')
    g1 = sp.Symbol('g1')
    g2 = sp.Symbol('g2')

    ##Matrices
    Q = (size**2)*sp.Matrix([[(1-e1), e2],[e2, 1+e1]])
    rvec = sp.Matrix([dx,dy])
    A = (1.-K)*sp.Matrix([[1-g1,-g2],[-g2,1+g1]])

    if(not suppressLensing):
        ##Translate the distrotion matrix to a lensed version
        Q = A.T*Q*A

    Pref = flux/(2.*pi*(Q.det()**0.5)) ##Sqrt detQ
    Surf = Pref*sp.exp(-0.5*rvec.transpose()*Q.inv()*rvec)

    ##Create function of surface brightness profile to specified order of differentiation
    dSurf = Surf
    for dd in range(len(der)):
        print 'Differentiating wrt:', der[dd]
        dSurf = dSurf.diff(der[dd])

    if printOnly:
        print 'Final Result is:', dSurf
    else:
        
        fSurf = sp.lambdify((dx,dy,size,e1,e2,flux), dSurf)
        
        ##Set up grid on which to evaluate
        delR = [xy[0]-cen[0], xy[1]-cen[1]] #[delX, delY]
        SB = np.zeros((xy[0].shape[0], xy[1].shape[0]))
        
        ## Can this be sped up?
        for i in range(SB.shape[0]):
            for j in range(SB.shape[1]):
                SB[i,j] = fSurf(delR[0][i], delR[1][j], isigma, ie1, ie2, iItot)
                
        return SB

### SymPy helper routines - For C++-style output


### Weave Declarations -- C++ Implementation ###

def gaussian_SBProfile_Weave(xy, cen, isigma, ie1, ie2, iItot, der = []):
    '''
    Routine that produces the SB profile and its derivatives using C++ code called through Weave inline.

    Note: As the code is compiled for the first run and then run from precompiled code, it may be the case that the code will be quickest when compiled in seperate routines

    The evaluation of the SB profile and its derivatives in the presence of a lensing field is involved using this method, therefore it has been neglected for now (The application of the method itself does not require lensing paramaters where the shear is taken as the average across a sample [e.g. ring test], however the simulation of sheared images may require this. In this case, only the lensed surface brightness profile itself is required, and this may be more easily implemented in the full matrix formalism of gaussian_SBProfile_Py in Python (numpy)
    
    '''
    
    from scipy import weave
    import numpy as np

    nX = xy[0].shape[0]; nY = xy[1].shape[0]

    dx = xy[0]-cen[0]
    dy = xy[1]-cen[1]
    SB = np.zeros((xy[0].shape[0], xy[1].shape[0]))

    if(cen[0] > xy[0].max() or cen[0] < xy[0].min()):
        raise ValueError('gaussian_SBProfile_Weave - Centroid (x) lies outwith the range of the PS, FATAL :'+str(cen))
    if(cen[1] > xy[1].max() or cen[1] < xy[1].min()):
        raise ValueError('gaussian_SBProfile_Weave - Centroid (y) lies outwith the range of the PS, FATAL :'+str(cen))

    ##Rename variables to fit in with Sympy output
    e1 = ie1
    e2 = ie2
    size = isigma
    flux = iItot

    weaveVar = ['SB', 'flux', 'e1', 'e2', 'size', 'dx', 'dy', 'nX', 'nY']

    ##Set up initial bit of code
    #Pos here accounts for the fact that apparently weave works on flattened arrays
    code = r"""
    int i;
    int j;
    int Pos;
    for(i = 0; i < nX; i++){
    for(j = 0; j < nY; j++){
    Pos = i*nX + j;
    SB[Pos] = """

    codeTail = r"""}}"""

    weaveArgs = [SB, flux, e1, e2, size, dx, dy, nX, nY, weaveVar, code, codeTail]

    if(len(der) == 0):
        ##SB profile directly
        runWeave_GaussSB(*weaveArgs)
        
    return SB.copy()

### ~~~~~~~~~ Support routines for Weave: Take the common code and append the C++ code to calcualte the SB and its derivatives. These are kept in seperate routines so that the correct precompiled version is used every time and not overwritten with subsequent calls

### --- Probably want to do this for lensing parameters also...

### --- To convert from SymPy output to C++ code, one must replace x**y -> pow(x,y), and dx -> dx[i], dy -> dy[j]

## Could a dictionary be used for input, since weaveVar is essentially the `key` of the entered parameters?


''' TEMPLATE FOR RUN WEAVE DECLARATIONS 

def runWeave_GaussSB_{...}(SB, flux, e1, e2, size, dx, dy, nX, nY, weaveVar, code, codeTail):
    from scipy import weave
    ##SB profile directly
    codeSB = r""" ... ;"""

    code += codeSB + codeTail
    ## Run the code through weave
    weave.inline(code, weaveVar, headers = ['<cmath>'])

'''

def runWeave_GaussSB(SB, flux, e1, e2, size, dx, dy, nX, nY, weaveVar, code, codeTail):
    from scipy import weave
    ##SB profile directly
    codeSB = r"""0.159154943091895*flux*pow(-pow(e1,2)*pow(size,4) - pow(e2,2)*pow(size,4) + pow(size,4),-0.5)*exp(0.5*(pow(dx[i],2)*e1 + pow(dx[i],2) - 2.0*dx[i]*dy[j]*e2 - pow(dy[j],2)*e1 + pow(dy[j],2))/(pow(size,2)*(pow(e1,2) + pow(e2,2) - 1.0)));"""

    code += codeSB + codeTail
    ## Run the code through weave
    weave.inline(code, weaveVar, headers = ['<cmath>'])

##### ----------------------------------- Command Line Run: Set up to run SymPy version with print output, thus allowing the scalar form for the SB profile and its derivatives to be calcualted easily for inclusion as C++ code -------------------------------#####

if __name__ == "__main__":
    ##Contains the routines if the code is run from command line, most likely to output SymPy result

    gaussian_SBProfile_Sympy(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, der = ['size'], printOnly = True)
